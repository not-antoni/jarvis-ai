const fs = require('fs');
const path = require('path');
const os = require('os');
const https = require('https');
const { spawn } = require('child_process');
const { pipeline } = require('stream/promises');
const { ensureFfmpeg } = require('./ffmpeg');

const BINARY_NAMES = {
    linux: 'yt-dlp',
    darwin: 'yt-dlp_macos',
    win32: 'yt-dlp.exe'
};

const BINARY_URLS = {
    linux: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp',
    darwin: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp_macos',
    win32: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp.exe'
};

const COOKIE_ENV_KEYS = [
    'YTDLP_COOKIES_JSON',
    'YTDLP_COOKIES',
    'YT_COOKIES_JSON',
    'YT_COOKIES',
    'YT_DLP_COOKIES'
];

const TEMP_DIR = path.join(os.tmpdir(), 'jarvis-music-cache');
const BIN_DIR = path.join(os.tmpdir(), 'jarvis-tools');
const MAX_FILE_AGE_MS = 15 * 60 * 1000;
const CLEANUP_DELAY_MS = 2 * 60 * 1000;
const COOKIE_FILE_NAME = 'youtube-cookies.txt';

const cache = new Map(); // videoId -> { path, refs, timer, lastAccess }
const pendingDownloads = new Map(); // videoId -> { promise, cancel }

async function ensureDirectories() {
    await fs.promises.mkdir(TEMP_DIR, { recursive: true });
    await fs.promises.mkdir(BIN_DIR, { recursive: true });
}

async function ensureBinary() {
    await ensureDirectories();

    const binaryName = BINARY_NAMES[process.platform];
    if (!binaryName) {
        throw new Error(`Unsupported platform for yt-dlp: ${process.platform}`);
    }

    const binaryPath = path.join(BIN_DIR, binaryName);
    try {
        await fs.promises.access(binaryPath, fs.constants.X_OK);
        return binaryPath;
    } catch {
        // continue to download
    }

    const downloadUrl = BINARY_URLS[process.platform];
    if (!downloadUrl) {
        throw new Error('No yt-dlp download URL for this platform.');
    }

    const tempPath = path.join(BIN_DIR, `${binaryName}.download`);

    await new Promise((resolve, reject) => {
        const onResponse = (res) => {
            const status = res.statusCode || 0;

            if (status >= 300 && status < 400 && res.headers.location) {
                const location = res.headers.location.startsWith('http')
                    ? res.headers.location
                    : new URL(res.headers.location, 'https://github.com').toString();

                res.destroy();
                https.get(location, onResponse).on('error', reject);
                return;
            }

            if (status !== 200) {
                res.resume();
                reject(new Error(`Failed to download yt-dlp (status ${status}).`));
                return;
            }

            const fileStream = fs.createWriteStream(tempPath, { mode: 0o755 });
            pipeline(res, fileStream)
                .then(resolve)
                .catch(reject);
        };

        https.get(downloadUrl, onResponse).on('error', reject);
    });

    await fs.promises.rename(tempPath, binaryPath);
    await fs.promises.chmod(binaryPath, 0o755);

    return binaryPath;
}

async function ensureCookiesFile() {
    const cookies = readCookiesFromEnv();
    if (!cookies?.length) {
        return null;
    }

    await ensureDirectories();
    const filePath = path.join(BIN_DIR, COOKIE_FILE_NAME);
    const lines = [
        '# Netscape HTTP Cookie File',
        '# Generated by Jarvis so yt-dlp can authenticate requests.'
    ];

    for (const cookie of cookies) {
        const name = cookie.name ?? cookie.key;
        const value = cookie.value ?? cookie.val ?? cookie.content;
        if (!name || typeof value === 'undefined') {
            continue;
        }

        const domain = cookie.domain?.startsWith('.') ? cookie.domain : `.${(cookie.domain || 'youtube.com').replace(/^\.?/, '')}`;
        const hostOnly = cookie.hostOnly ? 'FALSE' : 'TRUE';
        const pathValue = cookie.path ?? '/';
        const secure = cookie.secure ? 'TRUE' : 'FALSE';
        const expiry = cookie.expires ?? cookie.expirationDate ?? cookie.expiry ?? 0;
        const expiresAt = typeof expiry === 'number' && expiry > 0
            ? Math.floor(expiry > 10_000_000_000 ? expiry / 1000 : expiry)
            : 0;

        lines.push([
            domain,
            hostOnly,
            pathValue,
            secure,
            expiresAt,
            String(name),
            String(value)
        ].join('\t'));
    }

    await fs.promises.writeFile(filePath, `${lines.join('\n')}\n`, 'utf8');
    return filePath;
}

function readCookiesFromEnv() {
    for (const key of COOKIE_ENV_KEYS) {
        const raw = process.env[key];
        if (!raw || typeof raw !== 'string') {
            continue;
        }

        const trimmed = raw.trim();
        if (!trimmed.length) {
            continue;
        }

        if (trimmed.startsWith('[')) {
            try {
                return normaliseCookieArray(JSON.parse(trimmed));
            } catch (error) {
                console.warn(`Failed to parse ${key} JSON cookies:`, error?.message || error);
                continue;
            }
        }

        if (trimmed.startsWith('{')) {
            try {
                const parsed = JSON.parse(trimmed);
                if (Array.isArray(parsed?.cookies)) {
                    return normaliseCookieArray(parsed.cookies);
                }
            } catch (error) {
                console.warn(`Failed to parse ${key} cookie object:`, error?.message || error);
                continue;
            }
        }

        return convertLegacyCookieString(trimmed);
    }

    return null;
}

function normaliseCookieArray(input) {
    if (!Array.isArray(input)) {
        return null;
    }

    return input
        .map(cookie => {
            if (!cookie || typeof cookie !== 'object') {
                return null;
            }

            const name = cookie.name ?? cookie.key;
            const value = cookie.value ?? cookie.val ?? cookie.content;
            const domain = cookie.domain ?? '.youtube.com';

            if (!name || typeof value === 'undefined') {
                return null;
            }

            return {
                name: String(name),
                value: String(value),
                domain,
                hostOnly: Boolean(cookie.hostOnly),
                path: cookie.path ?? '/',
                secure: cookie.secure ?? true,
                expires: cookie.expires ?? cookie.expirationDate ?? cookie.expiry ?? 0
            };
        })
        .filter(Boolean);
}

function convertLegacyCookieString(raw) {
    const segments = raw
        .split(/;\s*/g)
        .map(segment => segment.trim())
        .filter(Boolean);

    if (!segments.length) {
        return null;
    }

    return segments
        .map(segment => {
            const [namePart, ...valueParts] = segment.split('=');
            if (!namePart || valueParts.length === 0) {
                return null;
            }

            const name = namePart.trim();
            const value = valueParts.join('=').trim();
            if (!name || !value) {
                return null;
            }

            return {
                name,
                value,
                domain: '.youtube.com',
                path: '/',
                secure: true,
                expires: 0
            };
        })
        .filter(Boolean);
}

function getTargetPaths(videoId) {
    const safeId = videoId.replace(/[^a-zA-Z0-9_-]/g, '_');
    const base = path.join(TEMP_DIR, safeId);
    return {
        base,
        finalPath: `${base}.opus`
    };
}

async function cleanupArtifacts(base) {
    const dir = path.dirname(base);
    const prefix = path.basename(base);
    try {
        const files = await fs.promises.readdir(dir);
        await Promise.all(
            files
                .filter(file => file.startsWith(prefix))
                .map(file => fs.promises.rm(path.join(dir, file), { force: true }))
        );
    } catch {
        // ignore
    }
}

async function createDownloadTask(videoId, videoUrl) {
    const binaryPath = await ensureBinary();
    const ffmpegPath = await ensureFfmpeg();
    const { base, finalPath } = getTargetPaths(videoId);
    const cookieFile = await ensureCookiesFile();

    await cleanupArtifacts(base);

    const args = [
        '-f', 'bestaudio/best',
        '--no-playlist',
        '--extract-audio',
        '--audio-format', 'opus',
        '--audio-quality', '0',
        '--output', `${base}.%(ext)s`,
        '--no-progress',
        '--ffmpeg-location', ffmpegPath,
        videoUrl
    ];

    if (cookieFile) {
        args.splice(args.length - 1, 0, '--cookies', cookieFile);
    }

    let cancelled = false;
    const child = spawn(binaryPath, args, {
        stdio: ['ignore', 'inherit', 'inherit'],
        env: { ...process.env, YTDLP_NO_CHECK: '1' }
    });

    const promise = new Promise((resolve, reject) => {
        const finalize = async (error) => {
            await cleanupArtifacts(base);
            reject(error);
        };

        child.on('error', finalize);
        child.on('close', async (code) => {
            if (cancelled) {
                await finalize(new Error('Download cancelled'));
                return;
            }

            if (code !== 0) {
                await finalize(new Error(`yt-dlp exited with code ${code}`));
                return;
            }

            try {
                const files = await fs.promises.readdir(TEMP_DIR);
                const output = files
                    .map(file => path.join(TEMP_DIR, file))
                    .find(file => file.startsWith(base) && file.endsWith('.opus'));

                if (!output) {
                    throw new Error('Extraction finished without producing an Opus file.');
                }

                await fs.promises.rename(output, finalPath);
                resolve(finalPath);
            } catch (error) {
                await finalize(error);
            }
        });
    });

    const cancel = () => {
        if (!cancelled) {
            cancelled = true;
            child.kill('SIGKILL');
        }
    };

    return { promise, cancel };
}

function scheduleCleanup(videoId, entry) {
    if (entry.timer) {
        clearTimeout(entry.timer);
    }

    entry.timer = setTimeout(async () => {
        try {
            if (entry.path) {
                await fs.promises.rm(entry.path, { force: true });
            }
        } catch (error) {
            console.warn('Failed to remove cached audio:', error.message || error);
        } finally {
            cache.delete(videoId);
        }
    }, CLEANUP_DELAY_MS).unref?.();
}

function cancelCleanup(entry) {
    if (entry?.timer) {
        clearTimeout(entry.timer);
        entry.timer = null;
    }
}

async function acquireAudio(videoId, videoUrl) {
    let entry = cache.get(videoId);

    if (entry && entry.path) {
        const fresh = await fileIsFresh(entry.path);
        if (!fresh) {
            await fs.promises.rm(entry.path, { force: true }).catch(() => {});
            cache.delete(videoId);
            entry = null;
        }
    }

    if (entry && entry.path) {
        cancelCleanup(entry);
        entry.refs += 1;
        entry.lastAccess = Date.now();
        return {
            filePath: entry.path,
            release: () => releaseAudio(videoId)
        };
    }

    const pending = pendingDownloads.get(videoId);
    if (pending) {
        const finalPath = await pending.promise;
        return {
            filePath: finalPath,
            release: () => releaseAudio(videoId)
        };
    }

    const task = await createDownloadTask(videoId, videoUrl);
    const wrappedPromise = task.promise
        .then((path) => {
            const cacheEntry = {
                path,
                refs: 1,
                lastAccess: Date.now(),
                timer: null
            };
            cache.set(videoId, cacheEntry);
            pendingDownloads.delete(videoId);
            return path;
        })
        .catch((error) => {
            pendingDownloads.delete(videoId);
            cache.delete(videoId);
            throw error;
        });

    pendingDownloads.set(videoId, { promise: wrappedPromise, cancel: task.cancel });

    const finalPath = await wrappedPromise;
    return {
        filePath: finalPath,
        release: () => releaseAudio(videoId)
    };
}

function cancelDownload(videoId) {
    const pending = pendingDownloads.get(videoId);
    if (pending) {
        pending.cancel();
    }
}

function releaseAudio(videoId) {
    const entry = cache.get(videoId);
    if (!entry) {
        return;
    }

    entry.refs = Math.max(0, entry.refs - 1);
    entry.lastAccess = Date.now();

    if (entry.refs === 0) {
        scheduleCleanup(videoId, entry);
    }
}

module.exports = {
    acquireAudio,
    cancelDownload
};
