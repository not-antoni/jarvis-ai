#!/usr/bin/env node
/**
 * Jarvis AI - Selfhost First-Time Setup Wizard
 * 
 * Interactive setup for VPS/selfhost deployments.
 * Guides users through configuration, validates settings,
 * and provides PM2/Nginx setup instructions.
 * 
 * Usage: 
 *   node scripts/selfhost-setup.js          # Interactive setup
 *   node scripts/selfhost-setup.js --verify # Verify current configuration
 *   node scripts/selfhost-setup.js --force  # Re-run setup from scratch
 */

const readline = require('readline');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync, spawnSync } = require('child_process');
const net = require('net');

const ENV_PATH = path.join(__dirname, '..', '.env');
const ENV_EXAMPLE_PATH = path.join(__dirname, '..', '.env.example');
const DATA_DIR = path.join(__dirname, '..', 'data');
const SETUP_COMPLETE_FILE = path.join(DATA_DIR, '.selfhost-setup-complete');
const PROJECT_ROOT = path.join(__dirname, '..');

// ANSI colors
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    dim: '\x1b[2m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

const log = {
    info: msg => console.log(`${colors.cyan}ℹ${colors.reset} ${msg}`),
    success: msg => console.log(`${colors.green}✓${colors.reset} ${msg}`),
    warn: msg => console.log(`${colors.yellow}⚠${colors.reset} ${msg}`),
    error: msg => console.log(`${colors.red}✗${colors.reset} ${msg}`),
    step: msg => console.log(`\n${colors.bright}${colors.blue}▶ ${msg}${colors.reset}`),
    header: msg => console.log(`\n${colors.bright}${colors.magenta}═══ ${msg} ═══${colors.reset}\n`)
};

class SelfhostSetup {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        this.envVars = {};
        this.existingEnv = {};
    }

    async prompt(question, defaultValue = '') {
        const defaultStr = defaultValue ? ` ${colors.dim}[${defaultValue}]${colors.reset}` : '';
        return new Promise(resolve => {
            this.rl.question(`${question}${defaultStr}: `, answer => {
                resolve(answer.trim() || defaultValue);
            });
        });
    }

    async promptYesNo(question, defaultYes = true) {
        const hint = defaultYes ? '[Y/n]' : '[y/N]';
        const answer = await this.prompt(`${question} ${hint}`);
        if (!answer) return defaultYes;
        return answer.toLowerCase().startsWith('y');
    }

    async promptSecret(question) {
        // Simplified: just use regular prompt to avoid stdin issues
        // The value won't be hidden but it's more reliable
        return this.prompt(question, '');
    }

    loadExistingEnv() {
        if (fs.existsSync(ENV_PATH)) {
            const content = fs.readFileSync(ENV_PATH, 'utf8');
            for (const line of content.split('\n')) {
                const match = line.match(/^([^#=]+)=(.*)$/);
                if (match) {
                    let value = match[2].trim();
                    // Remove quotes
                    if ((value.startsWith('"') && value.endsWith('"')) ||
                        (value.startsWith("'") && value.endsWith("'"))) {
                        value = value.slice(1, -1);
                    }
                    this.existingEnv[match[1].trim()] = value;
                }
            }
        }
    }

    generateMasterKey() {
        return crypto.randomBytes(32).toString('base64');
    }

    /**
     * Generate Cloudflare IP allowlist config
     * Fetches from Cloudflare's official IP list or uses fallback
     */
    generateCloudflareIpsConfig() {
        // Fallback IPs (as of 2024) - will be updated by systemd timer
        const ipv4 = [
            '173.245.48.0/20', '103.21.244.0/22', '103.22.200.0/22', '103.31.4.0/22',
            '141.101.64.0/18', '108.162.192.0/18', '190.93.240.0/20', '188.114.96.0/20',
            '197.234.240.0/22', '198.41.128.0/17', '162.158.0.0/15', '104.16.0.0/13',
            '104.24.0.0/14', '172.64.0.0/13', '131.0.72.0/22'
        ];
        const ipv6 = [
            '2400:cb00::/32', '2606:4700::/32', '2803:f800::/32', '2405:b500::/32',
            '2405:8100::/32', '2a06:98c0::/29', '2c0f:f248::/32'
        ];

        let config = `# Cloudflare IPs - Auto-generated by selfhost-setup.js
# Updated: ${new Date().toISOString()}
# Run scripts/update-cloudflare-ips.sh to refresh from Cloudflare

# IPv4
`;
        ipv4.forEach(ip => config += `allow ${ip};\n`);
        config += `\n# IPv6\n`;
        ipv6.forEach(ip => config += `allow ${ip};\n`);
        config += `
# Localhost for local testing
allow 127.0.0.1;
allow ::1;

# Deny all other IPs
deny all;
`;
        return config;
    }

    /**
     * Generate shell command to create Cloudflare IPs config
     */
    generateCloudflareIpsCommand() {
        const config = this.generateCloudflareIpsConfig();
        const escaped = config.replace(/'/g, "'\\''");
        return `echo '${escaped}' | sudo tee /etc/nginx/cloudflare-ips.conf > /dev/null`;
    }

    /**
     * Generate shell command to create Nginx config file with Cloudflare-only protection
     */
    generateNginxConfigCommand(domain, platformType = 'debian', enableCloudflareOnly = true) {
        const cfDir = path.join(PROJECT_ROOT, 'cloudflare');
        const hasCert = fs.existsSync(path.join(cfDir, 'cert.pem')) && fs.existsSync(path.join(cfDir, 'key.pem'));

        // Define paths where we will copy the certs to on the system
        const sysCertPath = `/etc/ssl/cloudflare/${domain}.pem`;
        const sysKeyPath = `/etc/ssl/cloudflare/${domain}.key`;

        let nginxConfig = '';

        // Default server block to reject direct IP/AWS hostname access
        if (enableCloudflareOnly && hasCert) {
            nginxConfig += `# Block direct IP/hostname access - only allow Cloudflare
# Catches: direct IP, AWS hostnames (ec2-*.amazonaws.com), etc.
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    http2 on;
    server_name _;
    
    ssl_certificate ${sysCertPath};
    ssl_certificate_key ${sysKeyPath};
    
    # Return 444 (close connection) - no response, frustrates bots
    return 444;
}

`;
        }

        if (hasCert) {
            nginxConfig += `server {
    listen 80;
    server_name ${domain} www.${domain};
    return 301 https://\\$host\\$request_uri;
}

server {
    listen 443 ssl;
    http2 on;
    server_name ${domain} www.${domain};

    ssl_certificate ${sysCertPath};
    ssl_certificate_key ${sysKeyPath};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;
${enableCloudflareOnly ? `
    # Only allow Cloudflare IPs
    include /etc/nginx/cloudflare-ips.conf;
` : ''}
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \\$host;
        proxy_set_header X-Real-IP \\$remote_addr;
        proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\$scheme;
        proxy_read_timeout 86400;
        proxy_buffering off;
    }
}`;
        } else {
            nginxConfig += `server {
    listen 80;
    server_name ${domain} www.${domain};
${enableCloudflareOnly ? `
    # Only allow Cloudflare IPs
    include /etc/nginx/cloudflare-ips.conf;
` : ''}
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \\$host;
        proxy_set_header X-Real-IP \\$remote_addr;
        proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\$scheme;
        proxy_read_timeout 86400;
        proxy_buffering off;
    }
}`;
        }

        // Escape for shell and write via tee
        const escaped = nginxConfig.replace(/'/g, "'\\''");

        // Always use conf.d for consistency
        const configPath = '/etc/nginx/conf.d/jarvis.conf';

        let cmd = `echo '${escaped}' | sudo tee ${configPath} > /dev/null`;

        if (hasCert) {
            // Add commands to create dir and copy certs
            cmd = `sudo mkdir -p /etc/ssl/cloudflare && sudo cp ${path.join(cfDir, 'cert.pem')} ${sysCertPath} && sudo cp ${path.join(cfDir, 'key.pem')} ${sysKeyPath} && sudo chmod 644 ${sysCertPath} && sudo chmod 600 ${sysKeyPath} && ${cmd}`;
        }

        return cmd;
    }

    /**
     * Generate commands to set up systemd timer for Cloudflare IP updates
     */
    generateSystemdTimerCommands() {
        const servicePath = path.join(PROJECT_ROOT, 'systemd', 'cloudflare-ips-update.service');
        const timerPath = path.join(PROJECT_ROOT, 'systemd', 'cloudflare-ips-update.timer');

        // Check if systemd files exist in project
        const hasSystemdFiles = fs.existsSync(servicePath) && fs.existsSync(timerPath);

        if (hasSystemdFiles) {
            return [
                `sudo cp ${servicePath} /etc/systemd/system/`,
                `sudo cp ${timerPath} /etc/systemd/system/`,
                'sudo systemctl daemon-reload',
                'sudo systemctl enable cloudflare-ips-update.timer',
                'sudo systemctl start cloudflare-ips-update.timer'
            ].join(' && ');
        }

        return null;
    }

    detectPublicIP() {
        try {
            // Try multiple methods
            const methods = [
                'curl -s --max-time 5 ifconfig.me',
                'curl -s --max-time 5 icanhazip.com',
                'curl -s --max-time 5 api.ipify.org',
                'hostname -I | awk \'{print $1}\''
            ];

            for (const cmd of methods) {
                try {
                    const ip = execSync(cmd, { encoding: 'utf8', timeout: 6000 }).trim();
                    if (ip && /^\d+\.\d+\.\d+\.\d+$/.test(ip)) {
                        return ip;
                    }
                } catch {
                    continue;
                }
            }
        } catch {
            // Fallback
        }
        return null;
    }

    /**
     * Check if local MongoDB is running on localhost:27017
     */
    async checkLocalMongo() {
        return new Promise(resolve => {
            const socket = new net.Socket();
            socket.setTimeout(2000);

            socket.on('connect', () => {
                socket.destroy();
                resolve(true);
            });

            socket.on('timeout', () => {
                socket.destroy();
                resolve(false);
            });

            socket.on('error', () => {
                socket.destroy();
                resolve(false);
            });

            socket.connect(27017, 'localhost');
        });
    }

    async run() {
        console.clear();
        log.header('Jarvis AI - Selfhost Setup Wizard');

        // Check if already set up
        if (fs.existsSync(SETUP_COMPLETE_FILE)) {
            log.info('Selfhost setup was already completed.');
            const rerun = await this.promptYesNo('Do you want to run setup again?', false);
            if (!rerun) {
                log.info('Exiting. Run with --force to skip this check.');
                this.rl.close();
                return;
            }
        }

        this.loadExistingEnv();

        // Step 1: Basic Info
        log.step('Step 1: Environment Detection');

        const detectedIP = this.detectPublicIP();
        if (detectedIP) {
            log.success(`Detected public IP: ${detectedIP}`);
        } else {
            log.warn('Could not auto-detect public IP');
        }

        const isVPS = await this.promptYesNo('Are you running on a VPS/cloud server (not localhost)?', true);

        // Step 2: Base URL Configuration
        log.step('Step 2: Base URL Configuration');

        let baseUrl = this.existingEnv.PUBLIC_BASE_URL || '';
        if (isVPS) {
            log.info('For OAuth callbacks and webhooks, you need a public URL.');
            log.info('Options: Use your IP (http://1.2.3.4:3000) or a domain (https://jarvis.example.com)');

            const suggestedUrl = detectedIP ? `http://${detectedIP}:3000` : '';
            baseUrl = await this.prompt('Enter your public base URL', suggestedUrl || baseUrl);

            if (baseUrl && !baseUrl.startsWith('http')) {
                baseUrl = `http://${baseUrl}`;
            }
            baseUrl = baseUrl.replace(/\/$/, ''); // Remove trailing slash
        } else {
            baseUrl = await this.prompt('Base URL (for local dev)', 'http://localhost:3000');
        }
        this.envVars.PUBLIC_BASE_URL = baseUrl;

        // Step 3: Discord Configuration
        log.step('Step 3: Discord Configuration');

        let discordToken = this.existingEnv.DISCORD_TOKEN;
        if (discordToken) {
            log.success('Discord token already configured');
            const change = await this.promptYesNo('Do you want to change it?', false);
            if (change) {
                discordToken = await this.promptSecret('Enter Discord Bot Token');
            }
        } else {
            log.warn('Discord token not found');
            discordToken = await this.promptSecret('Enter Discord Bot Token');
        }
        if (discordToken) this.envVars.DISCORD_TOKEN = discordToken;

        // Discord OAuth (for moderator dashboard)
        const hasOAuth = this.existingEnv.DISCORD_CLIENT_ID && this.existingEnv.DISCORD_CLIENT_SECRET;
        if (hasOAuth) {
            log.success('Discord OAuth already configured');
            this.envVars.DISCORD_CLIENT_ID = this.existingEnv.DISCORD_CLIENT_ID;
            this.envVars.DISCORD_CLIENT_SECRET = this.existingEnv.DISCORD_CLIENT_SECRET;
        } else {
            const setupOAuth = await this.promptYesNo('Set up Discord OAuth (for moderator dashboard)?', false);
            if (setupOAuth) {
                log.info(`\nIn Discord Developer Portal, add this redirect URL:`);
                log.info(`${colors.bright}${baseUrl}/auth/discord/callback${colors.reset}\n`);

                const clientId = await this.prompt('Discord Client ID', '');
                const clientSecret = await this.prompt('Discord Client Secret', '');

                if (clientId) this.envVars.DISCORD_CLIENT_ID = clientId;
                if (clientSecret) this.envVars.DISCORD_CLIENT_SECRET = clientSecret;
            }
        }

        // Step 4: Database Configuration
        log.step('Step 4: Database Configuration');

        const hasMongoMain = !!this.existingEnv.MONGO_URI_MAIN;
        const hasMongoVault = !!this.existingEnv.MONGO_URI_VAULT;

        if (hasMongoMain && hasMongoVault) {
            log.success('MongoDB URIs already configured');
        } else {
            log.info('MongoDB is required for full functionality.');
            log.info('Options: 1) Local MongoDB, 2) MongoDB Atlas, 3) No database (limited)');

            // Check if local MongoDB is running
            const localMongoRunning = await this.checkLocalMongo();

            if (localMongoRunning) {
                log.success('Local MongoDB detected on localhost:27017');
                const useLocalMongo = await this.promptYesNo('Use local MongoDB?', true);
                if (useLocalMongo) {
                    this.envVars.MONGO_URI_MAIN = 'mongodb://localhost:27017/jarvis';
                    this.envVars.MONGO_URI_VAULT = 'mongodb://localhost:27017/jarvis_vault';
                    log.success('Configured local MongoDB URIs');
                } else {
                    const mongoMain = await this.prompt('MongoDB Main URI', '');
                    const mongoVault = await this.prompt('MongoDB Vault URI', mongoMain);
                    if (mongoMain) this.envVars.MONGO_URI_MAIN = mongoMain;
                    if (mongoVault) this.envVars.MONGO_URI_VAULT = mongoVault;
                }
            } else {
                log.warn('Local MongoDB not detected on localhost:27017');
                log.info('Install MongoDB: sudo apt install mongodb-org && sudo systemctl start mongod');

                const useLocalDb = await this.promptYesNo('Continue without MongoDB (LOCAL_DB_MODE)?', false);
                if (useLocalDb) {
                    this.envVars.LOCAL_DB_MODE = '1';
                    this.envVars.ALLOW_START_WITHOUT_DB = '1';
                    log.warn('Using LOCAL_DB_MODE - some features like Starkbucks will be disabled');
                } else {
                    const mongoMain = await this.prompt('MongoDB Main URI (Atlas or custom)', '');
                    const mongoVault = await this.prompt('MongoDB Vault URI', mongoMain);
                    if (mongoMain) this.envVars.MONGO_URI_MAIN = mongoMain;
                    if (mongoVault) this.envVars.MONGO_URI_VAULT = mongoVault;
                }
            }
        }

        // Step 5: Security
        log.step('Step 5: Security Configuration');

        let masterKey = this.existingEnv.MASTER_KEY_BASE64;
        if (masterKey) {
            log.success('Master key already configured');
        } else {
            log.warn('No master key found - generating new one');
            masterKey = this.generateMasterKey();
            log.success(`Generated: ${masterKey.substring(0, 10)}...`);
        }
        this.envVars.MASTER_KEY_BASE64 = masterKey;

        // Step 6: Selfhost Mode
        log.step('Step 6: Selfhost Mode Configuration');

        this.envVars.DEPLOY_TARGET = 'selfhost';
        this.envVars.SELFHOST_MODE = 'true';
        log.success('Enabled selfhost mode');

        // Optional: AI Providers - skip if any are already configured
        log.step('Step 7: AI Provider Configuration (Optional)');

        const hasAnyAI = this.existingEnv.OPENROUTER_API_KEY || this.existingEnv.GROQ_API_KEY ||
            this.existingEnv.GOOGLE_AI_API_KEY || this.existingEnv.OPENAI_API_KEY;
        if (hasAnyAI) {
            log.success('AI providers already configured');
            // Preserve existing AI keys
            if (this.existingEnv.OPENROUTER_API_KEY) this.envVars.OPENROUTER_API_KEY = this.existingEnv.OPENROUTER_API_KEY;
            if (this.existingEnv.GROQ_API_KEY) this.envVars.GROQ_API_KEY = this.existingEnv.GROQ_API_KEY;
            if (this.existingEnv.GOOGLE_AI_API_KEY) this.envVars.GOOGLE_AI_API_KEY = this.existingEnv.GOOGLE_AI_API_KEY;
            if (this.existingEnv.OPENAI_API_KEY) this.envVars.OPENAI_API_KEY = this.existingEnv.OPENAI_API_KEY;
        } else {
            const configureAI = await this.promptYesNo('Configure AI providers now?', false);
            if (configureAI) {
                const openrouterKey = await this.prompt('OpenRouter API Key (leave empty to skip)', '');
                if (openrouterKey) this.envVars.OPENROUTER_API_KEY = openrouterKey;

                const groqKey = await this.prompt('Groq API Key (leave empty to skip)', '');
                if (groqKey) this.envVars.GROQ_API_KEY = groqKey;

                const googleKey = await this.prompt('Google AI API Key (leave empty to skip)', '');
                if (googleKey) this.envVars.GOOGLE_AI_API_KEY = googleKey;
            }
        }

        // Step 8: Cloudflare SSL (Optional)
        log.step('Step 8: Cloudflare SSL Configuration');
        await this.setupCloudflareSSL();

        // Step 9: System Setup (VPS only)
        if (isVPS) {
            log.step('Step 9: System Setup');
            await this.runSystemSetup();
        }

        // Step 10: Write Configuration
        log.step(isVPS ? 'Step 10: Saving Configuration' : 'Step 9: Saving Configuration');

        this.writeEnvFile();

        // Mark setup as complete
        fs.mkdirSync(DATA_DIR, { recursive: true });
        fs.writeFileSync(SETUP_COMPLETE_FILE, new Date().toISOString());

        // Step 10: Post-Setup Instructions
        log.header('Setup Complete!');

        console.log(`${colors.bright}Next Steps:${colors.reset}\n`);

        console.log(`1. ${colors.cyan}Update Discord Developer Portal:${colors.reset}`);
        console.log(`   - Go to https://discord.com/developers/applications`);
        console.log(`   - OAuth2 → Redirects → Add: ${colors.bright}${baseUrl}/auth/discord/callback${colors.reset}`);
        console.log(`   - OAuth2 → Redirects → Add: ${colors.bright}${baseUrl}/moderator/callback${colors.reset}\n`);

        if (isVPS) {
            console.log(`2. ${colors.cyan}Start the bot with PM2:${colors.reset}`);
            console.log(`   ${colors.dim}pm2 start index.js --name "jarvis" --max-memory-restart 500M${colors.reset}`);
            console.log(`   ${colors.dim}pm2 startup && pm2 save${colors.reset}\n`);
        }

        console.log(`${colors.green}Verify setup:${colors.reset} node scripts/selfhost-setup.js --verify`);
        console.log(`${colors.green}Start the bot:${colors.reset} npm start\n`);

        this.rl.close();
    }

    // Check if a command exists
    commandExists(cmd) {
        try {
            const result = spawnSync('which', [cmd], { encoding: 'utf8', timeout: 5000 });
            return result.status === 0 && result.stdout.trim().length > 0;
        } catch {
            return false;
        }
    }

    // Run a command and show output
    runCmd(cmd, description) {
        log.info(`Running: ${cmd}`);
        try {
            const result = execSync(cmd, {
                encoding: 'utf8',
                timeout: 120000,
                stdio: ['pipe', 'pipe', 'pipe']
            });
            if (result.trim()) {
                console.log(`   ${colors.dim}${result.trim().split('\n').slice(0, 3).join('\n   ')}${colors.reset}`);
            }
            log.success(description);
            return true;
        } catch (error) {
            log.error(`Failed: ${error.message}`);
            return false;
        }
    }

    // Run system setup commands
    async runSystemSetup() {
        log.info('This will install/configure system dependencies.');
        log.info('Some commands require sudo (you may be prompted for password).\n');

        const runSetup = await this.promptYesNo('Run automated system setup?', true);
        if (!runSetup) {
            log.info('Skipping system setup. You can run these manually later.');
            return;
        }

        const pm = new PackageManager();
        await pm.detect();
        log.info(`Detected Config: ${pm.type} (${pm.manager})`);

        const setupTasks = [];

        // Check and install ffmpeg
        if (!this.commandExists('ffmpeg')) {
            setupTasks.push({
                name: 'Install ffmpeg',
                cmd: pm.install('ffmpeg'),
                check: () => this.commandExists('ffmpeg'),
                envVar: { key: 'FFMPEG_PATH', value: '/usr/bin/ffmpeg' }
            });
        } else {
            log.success('ffmpeg already installed');
            this.envVars.FFMPEG_PATH = '/usr/bin/ffmpeg';
        }

        // Check and install PM2
        if (!this.commandExists('pm2')) {
            setupTasks.push({
                name: 'Install PM2',
                cmd: 'sudo npm install -g pm2',
                check: () => this.commandExists('pm2')
            });
        } else {
            log.success('PM2 already installed');
        }

        // Configure firewall
        const configureFirewall = await this.promptYesNo('Configure firewall (allow SSH + HTTP/HTTPS)?', true);
        if (configureFirewall) {
            if (pm.type === 'debian') {
                setupTasks.push({ name: 'Allow SSH', cmd: 'sudo ufw allow ssh', check: () => true });
                setupTasks.push({ name: 'Allow HTTP', cmd: 'sudo ufw allow 80', check: () => true });
                setupTasks.push({ name: 'Allow HTTPS', cmd: 'sudo ufw allow 443', check: () => true });
                setupTasks.push({ name: 'Enable firewall', cmd: 'echo "y" | sudo ufw enable', check: () => true });
            } else if (pm.type === 'rhel') {
                // Firewalld
                setupTasks.push({ name: 'Install firewalld', cmd: pm.install('firewalld'), check: () => true });
                setupTasks.push({ name: 'Start firewalld', cmd: 'sudo systemctl start firewalld && sudo systemctl enable firewalld', check: () => true });
                setupTasks.push({ name: 'Allow SSH', cmd: 'sudo firewall-cmd --permanent --add-service=ssh', check: () => true });
                setupTasks.push({ name: 'Allow HTTP', cmd: 'sudo firewall-cmd --permanent --add-service=http', check: () => true });
                setupTasks.push({ name: 'Allow HTTPS', cmd: 'sudo firewall-cmd --permanent --add-service=https', check: () => true });
                setupTasks.push({ name: 'Reload firewall', cmd: 'sudo firewall-cmd --reload', check: () => true });
            }
        }

        // Setup Nginx reverse proxy with Cloudflare-only protection
        const domain = this.envVars.JARVIS_DOMAIN || this.existingEnv.JARVIS_DOMAIN || '';
        if (domain) {
            const setupNginx = await this.promptYesNo(`Setup Nginx reverse proxy for ${domain}?`, true);
            if (setupNginx) {
                // Ask about Cloudflare-only protection
                const enableCloudflareOnly = await this.promptYesNo(
                    'Enable Cloudflare-only access? (blocks direct IP/AWS hostname access)',
                    true
                );

                setupTasks.push({
                    name: 'Install Nginx',
                    cmd: pm.install('nginx'),
                    check: () => this.commandExists('nginx')
                });

                // Create Cloudflare IPs config if enabled
                if (enableCloudflareOnly) {
                    setupTasks.push({
                        name: 'Create Cloudflare IPs allowlist',
                        cmd: this.generateCloudflareIpsCommand(),
                        check: () => true
                    });
                }

                // Nginx Config Generation with Cloudflare-only option
                setupTasks.push({
                    name: 'Create Nginx config',
                    cmd: this.generateNginxConfigCommand(domain, pm.type, enableCloudflareOnly),
                    check: () => true
                });

                // Fix default server conflict in nginx.conf
                setupTasks.push({
                    name: 'Fix nginx default server conflict',
                    cmd: "sudo sed -i 's/server_name  _;/server_name  localhost;/' /etc/nginx/nginx.conf 2>/dev/null || true",
                    check: () => true
                });

                // Remove default site if on Debian
                if (pm.type === 'debian') {
                    setupTasks.push({
                        name: 'Disable default site',
                        cmd: 'sudo rm -f /etc/nginx/sites-enabled/default',
                        check: () => true
                    });
                }

                setupTasks.push({
                    name: 'Restart Nginx',
                    cmd: 'sudo nginx -t && sudo systemctl restart nginx && sudo systemctl enable nginx',
                    check: () => true
                });

                // Setup systemd timer for Cloudflare IP updates
                if (enableCloudflareOnly) {
                    const timerCmd = this.generateSystemdTimerCommands();
                    if (timerCmd) {
                        setupTasks.push({
                            name: 'Setup Cloudflare IP auto-update timer',
                            cmd: timerCmd,
                            check: () => true
                        });
                        log.info('Cloudflare IPs will auto-update weekly (Sundays 3 AM)');
                    }
                }
            }
        }

        // Run npm install if node_modules missing
        const nodeModulesPath = path.join(PROJECT_ROOT, 'node_modules');
        if (!fs.existsSync(nodeModulesPath)) {
            setupTasks.push({
                name: 'Install npm dependencies',
                cmd: 'npm install',
                cwd: PROJECT_ROOT,
                check: () => fs.existsSync(nodeModulesPath)
            });
        } else {
            log.success('npm dependencies already installed');
        }

        // Create data directory
        if (!fs.existsSync(DATA_DIR)) {
            fs.mkdirSync(DATA_DIR, { recursive: true });
            log.success('Created data directory');
        }

        // Run setup tasks
        if (setupTasks.length > 0) {
            console.log('');
            for (const task of setupTasks) {
                log.info(`${task.name}...`);
                try {
                    const options = {
                        encoding: 'utf8',
                        timeout: 300000,
                        stdio: ['pipe', 'pipe', 'pipe']
                    };
                    if (task.cwd) options.cwd = task.cwd;

                    execSync(task.cmd, options);

                    if (task.check && task.check()) {
                        log.success(task.name);
                        if (task.envVar) {
                            this.envVars[task.envVar.key] = task.envVar.value;
                        }
                    } else if (task.check) {
                        log.warn(`${task.name} - completed but verification failed`);
                    } else {
                        log.success(task.name);
                    }
                } catch (error) {
                    log.error(`${task.name} failed: ${error.message}`);
                    const cont = await this.promptYesNo('Continue with remaining tasks?', true);
                    if (!cont) break;
                }
            }
        }

        // Set up PM2 startup if available
        if (this.commandExists('pm2')) {
            const setupPm2Startup = await this.promptYesNo('Configure PM2 to start on boot?', true);
            if (setupPm2Startup) {
                log.info('Setting up PM2 startup...');
                try {
                    // Get startup command
                    const startupCmd = execSync('pm2 startup systemd -u $USER --hp $HOME 2>&1 | grep "sudo" | head -1', {
                        encoding: 'utf8',
                        timeout: 30000,
                        shell: '/bin/bash'
                    }).trim();

                    if (startupCmd && startupCmd.includes('sudo')) {
                        log.info('Running PM2 startup command...');
                        execSync(startupCmd, { encoding: 'utf8', timeout: 60000, stdio: 'inherit' });
                        log.success('PM2 configured to start on boot');
                    }
                } catch (error) {
                    log.warn('PM2 startup setup needs manual intervention. Run: pm2 startup');
                }
            }
        }

        // VPS Performance Optimization
        await this.optimizeVPSPerformance();

        console.log('');
        log.success('System setup complete!');
    }

    // Optimize VPS for audio streaming performance
    async optimizeVPSPerformance() {
        log.step('VPS Performance Optimization');
        log.info('These optimizations improve audio streaming and reduce glitches.');

        const optimize = await this.promptYesNo('Apply VPS performance optimizations?', true);
        if (!optimize) {
            log.info('Skipping VPS optimization.');
            return;
        }

        const optimizations = [
            {
                name: 'Set swappiness to 5 (minimal swapping)',
                cmd: 'echo 5 | sudo tee /proc/sys/vm/swappiness > /dev/null',
                persist: 'echo "vm.swappiness=5" | sudo tee -a /etc/sysctl.conf > /dev/null 2>&1 || true'
            },
            {
                name: 'Drop memory caches',
                cmd: 'sudo sync && echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null'
            },
            {
                name: 'Disable transparent hugepages (reduces latency)',
                cmd: 'echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled > /dev/null 2>&1 || true'
            },
            {
                name: 'Increase max file descriptors',
                cmd: 'sudo sysctl -w fs.file-max=100000 > /dev/null 2>&1 || true',
                persist: 'echo "fs.file-max=100000" | sudo tee -a /etc/sysctl.conf > /dev/null 2>&1 || true'
            },
            {
                name: 'Optimize network buffers for streaming',
                cmd: 'sudo sysctl -w net.core.rmem_max=16777216 > /dev/null 2>&1 && sudo sysctl -w net.core.wmem_max=16777216 > /dev/null 2>&1 || true'
            }
        ];

        for (const opt of optimizations) {
            try {
                execSync(opt.cmd, { encoding: 'utf8', timeout: 10000, stdio: 'pipe' });
                if (opt.persist) {
                    try {
                        execSync(opt.persist, { encoding: 'utf8', timeout: 5000, stdio: 'pipe' });
                    } catch { /* ignore persist failures */ }
                }
                log.success(opt.name);
            } catch (error) {
                log.warn(`${opt.name} - skipped (may require root)`);
            }
        }

        // Check available memory
        try {
            const memInfo = execSync('free -m | grep Mem', { encoding: 'utf8', timeout: 5000 }).trim();
            const parts = memInfo.split(/\s+/);
            const totalMb = parseInt(parts[1], 10);
            const availMb = parseInt(parts[6] || parts[3], 10);

            log.info(`Memory: ${availMb}MB available / ${totalMb}MB total`);

            if (totalMb < 1024) {
                log.warn('Low memory VPS detected (<1GB). Consider upgrading for better audio performance.');
            }
        } catch { /* ignore */ }

        log.success('VPS optimization complete!');
    }

    async headers() {
        // 1. Check for API Token (Best)
        const token = this.envVars.CLOUDFLARE_API_TOKEN || this.existingEnv.CLOUDFLARE_API_TOKEN;
        if (token) {
            return {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            };
        }

        // 2. Check for Origin CA Key (Specialized for Certs)
        const originKey = this.envVars.CLOUDFLARE_ORIGIN_CA_KEY || this.existingEnv.CLOUDFLARE_ORIGIN_CA_KEY ||
            this.envVars.CLOUDFLARE_ORIGIN_CA_API_KEY || this.existingEnv.CLOUDFLARE_ORIGIN_CA_API_KEY;
        if (originKey) {
            return {
                'X-Auth-User-Service-Key': originKey,
                'Content-Type': 'application/json'
            };
        }

        // 3. Check for Global API Key + Email (Legacy/Standard)
        // Helper to get from either source
        const get = (k) => this.envVars[k] || this.existingEnv[k];

        const key = get('CLOUDFLARE_GLOBAL_API_KEY') || get('CLOUDFLARE_API_KEY');
        const email = get('CLOUDFLARE_EMAIL');

        if (key && email) {
            return {
                'X-Auth-Key': key,
                'X-Auth-Email': email,
                'Content-Type': 'application/json'
            };
        }

        return null;
    }

    async setupCloudflareSSL() {
        const domain = this.envVars.PUBLIC_DOMAIN || this.existingEnv.PUBLIC_DOMAIN ||
            (this.envVars.PUBLIC_BASE_URL ? new URL(this.envVars.PUBLIC_BASE_URL).hostname : null);

        if (!domain || domain === 'localhost' || /^\d+\.\d+\.\d+\.\d+$/.test(domain)) {
            log.info('Skipping Cloudflare SSL: No valid domain name configured.');
            return;
        }

        const setupSSL = await this.promptYesNo(`Setup Cloudflare SSL for ${domain}?`, true);
        if (!setupSSL) return;

        // 1. Get Credentials
        let headers = await this.headers();
        if (!headers) {
            log.info('Cloudflare credentials not found.');
            const useToken = await this.promptYesNo('Do you have an API Token (Recommended)?', true);

            if (useToken) {
                const token = await this.promptSecret('Cloudflare API Token');
                this.envVars.CLOUDFLARE_API_TOKEN = token;
            } else {
                const email = await this.prompt('Cloudflare Email');
                const key = await this.promptSecret('Cloudflare Global API Key');
                this.envVars.CLOUDFLARE_EMAIL = email;
                this.envVars.CLOUDFLARE_API_KEY = key;
            }
            headers = await this.headers();
        }

        // 2. Generate Certificate
        log.info('Generating Origin CA Certificate (15 years)...');
        try {
            const response = await fetch('https://api.cloudflare.com/client/v4/certificates', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    hostnames: [domain, `*.${domain}`],
                    requested_validity: 5475,
                    request_type: 'origin-rsa',
                    csr: null // Cloudflare generates key pair
                })
            });

            const data = await response.json();

            if (!data.success) {
                throw new Error(`Cloudflare API Error: ${data.errors ? data.errors.map(e => e.message).join(', ') : 'Unknown error'}`);
            }

            const cert = data.result.certificate;
            const key = data.result.private_key;

            // 3. Save Files
            const cfDir = path.join(PROJECT_ROOT, 'cloudflare');
            if (!fs.existsSync(cfDir)) fs.mkdirSync(cfDir, { recursive: true });

            fs.writeFileSync(path.join(cfDir, 'cert.pem'), cert);
            fs.writeFileSync(path.join(cfDir, 'key.pem'), key);

            // Set stricter permissions for private key
            try {
                fs.chmodSync(path.join(cfDir, 'key.pem'), 0o600);
            } catch (e) {
                // Ignore if cannot chmod (e.g. Windows)
            }

            log.success('Successfully generated and saved Cloudflare Origin Certificate!');
            log.info(`Cert: ${path.join(cfDir, 'cert.pem')}`);
            log.info(`Key:  ${path.join(cfDir, 'key.pem')}`);

            return true; // SSL set up successfully

        } catch (error) {
            log.error(`Failed to generate certs: ${error.message}`);
            log.warn('You can manually place cert.pem and key.pem in the cloudflare/ directory.');
            return false;
        }
    }

    writeEnvFile() {
        // APPEND-ONLY MODE: Only add/update variables, never remove existing ones

        if (!fs.existsSync(ENV_PATH)) {
            // No existing .env - create new one with just our vars
            let content = '# Jarvis AI - Environment Configuration\n';
            content += `# Generated by selfhost-setup.js on ${new Date().toISOString()}\n\n`;

            for (const [key, value] of Object.entries(this.envVars)) {
                const needsQuotes = /[\s#=]/.test(value);
                content += needsQuotes ? `${key}="${value}"\n` : `${key}=${value}\n`;
            }

            fs.writeFileSync(ENV_PATH, content);
            log.success('Created new .env configuration');
            return;
        }

        // Read existing .env content
        let existingContent = fs.readFileSync(ENV_PATH, 'utf8');

        // Backup existing .env first
        const backupPath = `${ENV_PATH}.backup.${Date.now()}`;
        fs.copyFileSync(ENV_PATH, backupPath);
        log.info(`Backed up existing .env to ${path.basename(backupPath)}`);

        // Track what we've updated vs what needs to be appended
        const toAppend = [];

        for (const [key, value] of Object.entries(this.envVars)) {
            const needsQuotes = /[\s#=]/.test(value);
            const formattedValue = needsQuotes ? `"${value}"` : value;

            // Check if key already exists in file
            const keyRegex = new RegExp(`^${key}=.*$`, 'm');

            if (keyRegex.test(existingContent)) {
                // Update existing key in place
                existingContent = existingContent.replace(keyRegex, `${key}=${formattedValue}`);
                log.info(`Updated: ${key}`);
            } else {
                // Key doesn't exist - append it
                toAppend.push({ key, value: formattedValue });
            }
        }

        // Append new variables at the end
        if (toAppend.length > 0) {
            existingContent = existingContent.trimEnd();
            existingContent += '\n\n# Added by selfhost-setup.js\n';
            for (const { key, value } of toAppend) {
                existingContent += `${key}=${value}\n`;
                log.info(`Added: ${key}`);
            }
        }

        fs.writeFileSync(ENV_PATH, existingContent);
        log.success('Updated .env configuration (append-only mode)');
    }
}

/**
 * System verification checks
 */
class SystemVerifier {
    constructor() {
        this.results = { passed: 0, warnings: 0, failed: 0, checks: [] };
    }

    addResult(name, status, message) {
        this.results.checks.push({ name, status, message });
        if (status === 'pass') this.results.passed++;
        else if (status === 'warn') this.results.warnings++;
        else this.results.failed++;
    }

    // Check if a command exists
    commandExists(cmd) {
        try {
            const result = spawnSync('which', [cmd], { encoding: 'utf8', timeout: 5000 });
            return result.status === 0 && result.stdout.trim().length > 0;
        } catch {
            return false;
        }
    }

    // Check if a port is in use
    async checkPort(port) {
        return new Promise(resolve => {
            const server = net.createServer();
            server.once('error', () => resolve(true)); // Port in use
            server.once('listening', () => {
                server.close();
                resolve(false); // Port available
            });
            server.listen(port, '127.0.0.1');
        });
    }

    // Get installed Node version
    getNodeVersion() {
        try {
            return process.version;
        } catch {
            return null;
        }
    }

    // Check ffmpeg
    checkFfmpeg() {
        if (this.commandExists('ffmpeg')) {
            try {
                const version = execSync('ffmpeg -version 2>&1 | head -1', { encoding: 'utf8', timeout: 5000 }).trim();
                this.addResult('ffmpeg', 'pass', version.substring(0, 60));
                return '/usr/bin/ffmpeg';
            } catch {
                this.addResult('ffmpeg', 'pass', 'Installed');
                return '/usr/bin/ffmpeg';
            }
        } else {
            this.addResult('ffmpeg', 'warn', 'Not installed - yt-dlp may show warnings. Install: sudo apt install ffmpeg');
            return null;
        }
    }

    // Check PM2
    checkPM2() {
        if (this.commandExists('pm2')) {
            try {
                const version = execSync('pm2 --version', { encoding: 'utf8', timeout: 5000 }).trim();
                this.addResult('PM2', 'pass', `Version ${version}`);
                return true;
            } catch {
                this.addResult('PM2', 'pass', 'Installed');
                return true;
            }
        } else {
            this.addResult('PM2', 'warn', 'Not installed - recommended for production. Install: sudo npm install -g pm2');
            return false;
        }
    }

    // Check Node version
    checkNode() {
        const version = this.getNodeVersion();
        const major = parseInt(version.replace('v', '').split('.')[0], 10);
        if (major >= 18) {
            this.addResult('Node.js', 'pass', version);
        } else if (major >= 16) {
            this.addResult('Node.js', 'warn', `${version} - recommend v18+`);
        } else {
            this.addResult('Node.js', 'fail', `${version} - requires v16+`);
        }
    }

    // Check .env file
    checkEnvFile() {
        if (!fs.existsSync(ENV_PATH)) {
            this.addResult('.env file', 'fail', 'Missing - run setup first');
            return null;
        }

        const content = fs.readFileSync(ENV_PATH, 'utf8');
        const env = {};
        for (const line of content.split('\n')) {
            const match = line.match(/^([^#=]+)=(.*)$/);
            if (match) {
                let value = match[2].trim();
                if ((value.startsWith('"') && value.endsWith('"')) ||
                    (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }
                env[match[1].trim()] = value;
            }
        }

        this.addResult('.env file', 'pass', 'Found');
        return env;
    }

    // Check critical env vars
    checkEnvVars(env) {
        if (!env) return;

        // Required
        const required = ['DISCORD_TOKEN', 'MASTER_KEY_BASE64'];
        for (const key of required) {
            if (env[key] && env[key].length > 5) {
                this.addResult(key, 'pass', 'Configured');
            } else {
                this.addResult(key, 'fail', 'Missing or invalid');
            }
        }

        // Selfhost mode
        const isSelfhost = env.DEPLOY_TARGET === 'selfhost' || env.SELFHOST_MODE === 'true';
        if (isSelfhost) {
            this.addResult('Selfhost Mode', 'pass', 'Enabled');
        } else {
            this.addResult('Selfhost Mode', 'warn', 'Not enabled - set DEPLOY_TARGET=selfhost');
        }

        // PUBLIC_BASE_URL
        if (env.PUBLIC_BASE_URL && env.PUBLIC_BASE_URL.length > 5) {
            this.addResult('PUBLIC_BASE_URL', 'pass', env.PUBLIC_BASE_URL);
        } else if (isSelfhost) {
            this.addResult('PUBLIC_BASE_URL', 'warn', 'Not set - OAuth callbacks may fail');
        }

        // Database
        const hasLocalDb = env.LOCAL_DB_MODE === '1' || env.ALLOW_START_WITHOUT_DB === '1';
        if (env.MONGO_URI_MAIN && env.MONGO_URI_MAIN.length > 10) {
            this.addResult('MongoDB', 'pass', 'Configured');
        } else if (hasLocalDb) {
            this.addResult('MongoDB', 'warn', 'Using LOCAL_DB_MODE (limited features)');
        } else {
            this.addResult('MongoDB', 'fail', 'Not configured');
        }

        // AI Providers
        const aiKeys = ['OPENROUTER_API_KEY', 'GROQ_API_KEY', 'GOOGLE_AI_API_KEY', 'OPENAI', 'OPENAI_API_KEY'];
        const hasAI = aiKeys.some(k => env[k] && env[k].length > 10);
        if (hasAI) {
            this.addResult('AI Providers', 'pass', 'At least one configured');
        } else {
            this.addResult('AI Providers', 'warn', 'None configured - AI features will be limited');
        }

        // ffmpeg path
        if (env.FFMPEG_PATH) {
            this.addResult('FFMPEG_PATH', 'pass', env.FFMPEG_PATH);
        }
    }

    // Check if port is available
    async checkPortAvailability() {
        const port = process.env.PORT || 3000;
        const inUse = await this.checkPort(port);
        if (inUse) {
            this.addResult(`Port ${port}`, 'warn', 'Already in use - bot may already be running');
        } else {
            this.addResult(`Port ${port}`, 'pass', 'Available');
        }
    }

    // Check node_modules
    checkNodeModules() {
        const nodeModulesPath = path.join(PROJECT_ROOT, 'node_modules');
        if (fs.existsSync(nodeModulesPath)) {
            this.addResult('Dependencies', 'pass', 'node_modules exists');
        } else {
            this.addResult('Dependencies', 'fail', 'node_modules missing - run: npm install');
        }
    }

    // Check disk space
    checkDiskSpace() {
        try {
            const result = execSync("df -h . | tail -1 | awk '{print $4, $5}'", {
                encoding: 'utf8',
                timeout: 5000
            }).trim();
            const [available, usedPercent] = result.split(' ');
            const usedNum = parseInt(usedPercent.replace('%', ''), 10);

            if (usedNum > 90) {
                this.addResult('Disk Space', 'fail', `${available} available (${usedPercent} used) - critically low!`);
            } else if (usedNum > 80) {
                this.addResult('Disk Space', 'warn', `${available} available (${usedPercent} used) - getting low`);
            } else {
                this.addResult('Disk Space', 'pass', `${available} available (${usedPercent} used)`);
            }
        } catch {
            this.addResult('Disk Space', 'warn', 'Could not check disk space');
        }
    }

    // Check memory
    checkMemory() {
        try {
            const result = execSync("free -h | grep Mem | awk '{print $2, $7}'", {
                encoding: 'utf8',
                timeout: 5000
            }).trim();
            const [total, available] = result.split(' ');
            this.addResult('Memory', 'pass', `${available} available of ${total}`);
        } catch {
            // Try alternative for systems without 'free'
            try {
                const memInfo = fs.readFileSync('/proc/meminfo', 'utf8');
                const match = memInfo.match(/MemAvailable:\s+(\d+)/);
                if (match) {
                    const availMB = Math.round(parseInt(match[1], 10) / 1024);
                    this.addResult('Memory', 'pass', `${availMB}MB available`);
                }
            } catch {
                this.addResult('Memory', 'warn', 'Could not check memory');
            }
        }
    }

    // Check Discord OAuth configuration
    checkDiscordOAuth(env) {
        if (!env) return;

        const hasClientId = env.DISCORD_CLIENT_ID && env.DISCORD_CLIENT_ID.length > 10;
        const hasClientSecret = env.DISCORD_CLIENT_SECRET && env.DISCORD_CLIENT_SECRET.length > 10;

        if (hasClientId && hasClientSecret) {
            this.addResult('Discord OAuth', 'pass', 'Client ID and Secret configured');
        } else if (hasClientId && !hasClientSecret) {
            this.addResult('Discord OAuth', 'fail', 'Client ID set but Secret missing');
        } else {
            this.addResult('Discord OAuth', 'warn', 'Not configured - moderator dashboard will use password auth');
        }
    }

    // Check yt-dlp binary
    checkYtDlp() {
        const ytdlpPath = path.join(PROJECT_ROOT, 'bin', 'yt-dlp');
        const ytdlpPathWin = path.join(PROJECT_ROOT, 'bin', 'yt-dlp.exe');

        if (fs.existsSync(ytdlpPath) || fs.existsSync(ytdlpPathWin)) {
            this.addResult('yt-dlp', 'pass', 'Binary exists in bin/');
        } else {
            this.addResult('yt-dlp', 'warn', 'Not downloaded yet - will auto-download on first use');
        }
    }

    // Check data directory
    checkDataDir() {
        if (fs.existsSync(DATA_DIR)) {
            try {
                fs.accessSync(DATA_DIR, fs.constants.W_OK);
                this.addResult('Data Directory', 'pass', 'Exists and writable');
            } catch {
                this.addResult('Data Directory', 'fail', 'Exists but not writable');
            }
        } else {
            this.addResult('Data Directory', 'warn', 'Does not exist - will be created on first run');
        }
    }

    // Run all checks
    async runAll() {
        log.header('System Verification');

        log.step('Checking system dependencies...');
        this.checkNode();
        this.checkFfmpeg();
        this.checkPM2();
        this.checkYtDlp();
        this.checkNodeModules();

        log.step('Checking system resources...');
        this.checkDiskSpace();
        this.checkMemory();
        this.checkDataDir();

        log.step('Checking configuration...');
        const env = this.checkEnvFile();
        this.checkEnvVars(env);
        this.checkDiscordOAuth(env);

        log.step('Checking network...');
        await this.checkPortAvailability();

        // Print results
        console.log('\n');
        for (const check of this.results.checks) {
            const icon = check.status === 'pass' ? `${colors.green}✓` :
                check.status === 'warn' ? `${colors.yellow}⚠` :
                    `${colors.red}✗`;
            console.log(`${icon}${colors.reset} ${colors.bright}${check.name}${colors.reset}: ${check.message}`);
        }

        console.log('\n' + '─'.repeat(50));
        console.log(`${colors.green}Passed: ${this.results.passed}${colors.reset} | ` +
            `${colors.yellow}Warnings: ${this.results.warnings}${colors.reset} | ` +
            `${colors.red}Failed: ${this.results.failed}${colors.reset}`);

        if (this.results.failed > 0) {
            console.log(`\n${colors.red}Fix the failed checks before running the bot.${colors.reset}`);
            return false;
        } else if (this.results.warnings > 0) {
            console.log(`\n${colors.yellow}Warnings found - bot will run but some features may be limited.${colors.reset}`);
            return true;
        } else {
            console.log(`\n${colors.green}All checks passed! Ready to start.${colors.reset}`);
            return true;
        }
    }
}

// Parse command line arguments
const args = process.argv.slice(2);
const verifyMode = args.includes('--verify') || args.includes('-v');
const forceSetup = args.includes('--force') || args.includes('-f');

if (forceSetup) {
    if (fs.existsSync(SETUP_COMPLETE_FILE)) {
        fs.unlinkSync(SETUP_COMPLETE_FILE);
    }
}

// Run appropriate mode
if (verifyMode) {
    // Verification mode
    const verifier = new SystemVerifier();
    verifier.runAll().then(success => {
        process.exit(success ? 0 : 1);
    });
} else {
    // Interactive setup mode
    const setup = new SelfhostSetup();
    setup.run()
        .then(() => {
            process.exit(0);
        })
        .catch(err => {
            console.error('\n' + colors.red + 'Setup failed:' + colors.reset, err.message || err);
            console.error(colors.dim + 'Stack trace:' + colors.reset, err.stack || 'N/A');
            if (setup.rl) {
                setup.rl.close();
            }
            process.exit(1);
        });

    // Handle unexpected readline close
    setup.rl.on('close', () => {
        console.error('\n' + colors.yellow + 'Setup interrupted.' + colors.reset);
    });
}

/**
 * Package manager detection and abstraction
 */
class PackageManager {
    constructor() {
        this.manager = null;
        this.type = null; // 'debian' or 'rhel'
    }

    async detect() {
        if (this.commandExists('apt-get')) {
            this.manager = 'apt-get';
            this.type = 'debian';
        } else if (this.commandExists('dnf')) {
            this.manager = 'dnf';
            this.type = 'rhel';
        } else if (this.commandExists('yum')) {
            this.manager = 'yum';
            this.type = 'rhel';
        } else {
            this.manager = 'unknown';
            this.type = 'unknown';
        }
    }

    commandExists(cmd) {
        try {
            const result = spawnSync('which', [cmd], { encoding: 'utf8', timeout: 5000 });
            return result.status === 0 && result.stdout.trim().length > 0;
        } catch {
            return false;
        }
    }

    install(packageNames) {
        if (this.type === 'debian') {
            return `sudo apt-get update && sudo apt-get install -y ${packageNames}`;
        } else if (this.type === 'rhel') {
            // RHEL/CentOS/Amazon Linux
            if (packageNames.includes('ffmpeg')) {
                // Try install but don't fail hard if missing (user warned in output)
                return `sudo ${this.manager} install -y ffmpeg || echo "Warning: ffmpeg install failed. Enable RPM Fusion or install static binary."`;
            }
            return `sudo ${this.manager} install -y ${packageNames}`;
        } else {
            return `echo "Manual install required for: ${packageNames}"`;
        }
    }
}
